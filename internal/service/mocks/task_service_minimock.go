// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i test_task/internal/service.TaskService -o task_service_minimock.go -n TaskServiceMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	"test_task/models"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TaskServiceMock implements mm_service.TaskService
type TaskServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelAllTasks          func()
	funcCancelAllTasksOrigin    string
	inspectFuncCancelAllTasks   func()
	afterCancelAllTasksCounter  uint64
	beforeCancelAllTasksCounter uint64
	CancelAllTasksMock          mTaskServiceMockCancelAllTasks

	funcCheckTaskStatus          func(taskIdentification string) (tp1 *models.Task, err error)
	funcCheckTaskStatusOrigin    string
	inspectFuncCheckTaskStatus   func(taskIdentification string)
	afterCheckTaskStatusCounter  uint64
	beforeCheckTaskStatusCounter uint64
	CheckTaskStatusMock          mTaskServiceMockCheckTaskStatus

	funcCreateTask          func(task *models.Task) (taskId string, err error)
	funcCreateTaskOrigin    string
	inspectFuncCreateTask   func(task *models.Task)
	afterCreateTaskCounter  uint64
	beforeCreateTaskCounter uint64
	CreateTaskMock          mTaskServiceMockCreateTask
}

// NewTaskServiceMock returns a mock for mm_service.TaskService
func NewTaskServiceMock(t minimock.Tester) *TaskServiceMock {
	m := &TaskServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelAllTasksMock = mTaskServiceMockCancelAllTasks{mock: m}

	m.CheckTaskStatusMock = mTaskServiceMockCheckTaskStatus{mock: m}
	m.CheckTaskStatusMock.callArgs = []*TaskServiceMockCheckTaskStatusParams{}

	m.CreateTaskMock = mTaskServiceMockCreateTask{mock: m}
	m.CreateTaskMock.callArgs = []*TaskServiceMockCreateTaskParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTaskServiceMockCancelAllTasks struct {
	optional           bool
	mock               *TaskServiceMock
	defaultExpectation *TaskServiceMockCancelAllTasksExpectation
	expectations       []*TaskServiceMockCancelAllTasksExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TaskServiceMockCancelAllTasksExpectation specifies expectation struct of the TaskService.CancelAllTasks
type TaskServiceMockCancelAllTasksExpectation struct {
	mock *TaskServiceMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Optional() *mTaskServiceMockCancelAllTasks {
	mmCancelAllTasks.optional = true
	return mmCancelAllTasks
}

// Expect sets up expected params for TaskService.CancelAllTasks
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Expect() *mTaskServiceMockCancelAllTasks {
	if mmCancelAllTasks.mock.funcCancelAllTasks != nil {
		mmCancelAllTasks.mock.t.Fatalf("TaskServiceMock.CancelAllTasks mock is already set by Set")
	}

	if mmCancelAllTasks.defaultExpectation == nil {
		mmCancelAllTasks.defaultExpectation = &TaskServiceMockCancelAllTasksExpectation{}
	}

	return mmCancelAllTasks
}

// Inspect accepts an inspector function that has same arguments as the TaskService.CancelAllTasks
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Inspect(f func()) *mTaskServiceMockCancelAllTasks {
	if mmCancelAllTasks.mock.inspectFuncCancelAllTasks != nil {
		mmCancelAllTasks.mock.t.Fatalf("Inspect function is already set for TaskServiceMock.CancelAllTasks")
	}

	mmCancelAllTasks.mock.inspectFuncCancelAllTasks = f

	return mmCancelAllTasks
}

// Return sets up results that will be returned by TaskService.CancelAllTasks
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Return() *TaskServiceMock {
	if mmCancelAllTasks.mock.funcCancelAllTasks != nil {
		mmCancelAllTasks.mock.t.Fatalf("TaskServiceMock.CancelAllTasks mock is already set by Set")
	}

	if mmCancelAllTasks.defaultExpectation == nil {
		mmCancelAllTasks.defaultExpectation = &TaskServiceMockCancelAllTasksExpectation{mock: mmCancelAllTasks.mock}
	}

	mmCancelAllTasks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelAllTasks.mock
}

// Set uses given function f to mock the TaskService.CancelAllTasks method
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Set(f func()) *TaskServiceMock {
	if mmCancelAllTasks.defaultExpectation != nil {
		mmCancelAllTasks.mock.t.Fatalf("Default expectation is already set for the TaskService.CancelAllTasks method")
	}

	if len(mmCancelAllTasks.expectations) > 0 {
		mmCancelAllTasks.mock.t.Fatalf("Some expectations are already set for the TaskService.CancelAllTasks method")
	}

	mmCancelAllTasks.mock.funcCancelAllTasks = f
	mmCancelAllTasks.mock.funcCancelAllTasksOrigin = minimock.CallerInfo(1)
	return mmCancelAllTasks.mock
}

// Times sets number of times TaskService.CancelAllTasks should be invoked
func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) Times(n uint64) *mTaskServiceMockCancelAllTasks {
	if n == 0 {
		mmCancelAllTasks.mock.t.Fatalf("Times of TaskServiceMock.CancelAllTasks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelAllTasks.expectedInvocations, n)
	mmCancelAllTasks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelAllTasks
}

func (mmCancelAllTasks *mTaskServiceMockCancelAllTasks) invocationsDone() bool {
	if len(mmCancelAllTasks.expectations) == 0 && mmCancelAllTasks.defaultExpectation == nil && mmCancelAllTasks.mock.funcCancelAllTasks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelAllTasks.mock.afterCancelAllTasksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelAllTasks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelAllTasks implements mm_service.TaskService
func (mmCancelAllTasks *TaskServiceMock) CancelAllTasks() {
	mm_atomic.AddUint64(&mmCancelAllTasks.beforeCancelAllTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelAllTasks.afterCancelAllTasksCounter, 1)

	mmCancelAllTasks.t.Helper()

	if mmCancelAllTasks.inspectFuncCancelAllTasks != nil {
		mmCancelAllTasks.inspectFuncCancelAllTasks()
	}

	if mmCancelAllTasks.CancelAllTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelAllTasks.CancelAllTasksMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancelAllTasks.funcCancelAllTasks != nil {
		mmCancelAllTasks.funcCancelAllTasks()
		return
	}
	mmCancelAllTasks.t.Fatalf("Unexpected call to TaskServiceMock.CancelAllTasks.")

}

// CancelAllTasksAfterCounter returns a count of finished TaskServiceMock.CancelAllTasks invocations
func (mmCancelAllTasks *TaskServiceMock) CancelAllTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelAllTasks.afterCancelAllTasksCounter)
}

// CancelAllTasksBeforeCounter returns a count of TaskServiceMock.CancelAllTasks invocations
func (mmCancelAllTasks *TaskServiceMock) CancelAllTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelAllTasks.beforeCancelAllTasksCounter)
}

// MinimockCancelAllTasksDone returns true if the count of the CancelAllTasks invocations corresponds
// the number of defined expectations
func (m *TaskServiceMock) MinimockCancelAllTasksDone() bool {
	if m.CancelAllTasksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelAllTasksMock.invocationsDone()
}

// MinimockCancelAllTasksInspect logs each unmet expectation
func (m *TaskServiceMock) MinimockCancelAllTasksInspect() {
	for _, e := range m.CancelAllTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TaskServiceMock.CancelAllTasks")
		}
	}

	afterCancelAllTasksCounter := mm_atomic.LoadUint64(&m.afterCancelAllTasksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelAllTasksMock.defaultExpectation != nil && afterCancelAllTasksCounter < 1 {
		m.t.Errorf("Expected call to TaskServiceMock.CancelAllTasks at\n%s", m.CancelAllTasksMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelAllTasks != nil && afterCancelAllTasksCounter < 1 {
		m.t.Errorf("Expected call to TaskServiceMock.CancelAllTasks at\n%s", m.funcCancelAllTasksOrigin)
	}

	if !m.CancelAllTasksMock.invocationsDone() && afterCancelAllTasksCounter > 0 {
		m.t.Errorf("Expected %d calls to TaskServiceMock.CancelAllTasks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelAllTasksMock.expectedInvocations), m.CancelAllTasksMock.expectedInvocationsOrigin, afterCancelAllTasksCounter)
	}
}

type mTaskServiceMockCheckTaskStatus struct {
	optional           bool
	mock               *TaskServiceMock
	defaultExpectation *TaskServiceMockCheckTaskStatusExpectation
	expectations       []*TaskServiceMockCheckTaskStatusExpectation

	callArgs []*TaskServiceMockCheckTaskStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TaskServiceMockCheckTaskStatusExpectation specifies expectation struct of the TaskService.CheckTaskStatus
type TaskServiceMockCheckTaskStatusExpectation struct {
	mock               *TaskServiceMock
	params             *TaskServiceMockCheckTaskStatusParams
	paramPtrs          *TaskServiceMockCheckTaskStatusParamPtrs
	expectationOrigins TaskServiceMockCheckTaskStatusExpectationOrigins
	results            *TaskServiceMockCheckTaskStatusResults
	returnOrigin       string
	Counter            uint64
}

// TaskServiceMockCheckTaskStatusParams contains parameters of the TaskService.CheckTaskStatus
type TaskServiceMockCheckTaskStatusParams struct {
	taskIdentification string
}

// TaskServiceMockCheckTaskStatusParamPtrs contains pointers to parameters of the TaskService.CheckTaskStatus
type TaskServiceMockCheckTaskStatusParamPtrs struct {
	taskIdentification *string
}

// TaskServiceMockCheckTaskStatusResults contains results of the TaskService.CheckTaskStatus
type TaskServiceMockCheckTaskStatusResults struct {
	tp1 *models.Task
	err error
}

// TaskServiceMockCheckTaskStatusOrigins contains origins of expectations of the TaskService.CheckTaskStatus
type TaskServiceMockCheckTaskStatusExpectationOrigins struct {
	origin                   string
	originTaskIdentification string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Optional() *mTaskServiceMockCheckTaskStatus {
	mmCheckTaskStatus.optional = true
	return mmCheckTaskStatus
}

// Expect sets up expected params for TaskService.CheckTaskStatus
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Expect(taskIdentification string) *mTaskServiceMockCheckTaskStatus {
	if mmCheckTaskStatus.mock.funcCheckTaskStatus != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by Set")
	}

	if mmCheckTaskStatus.defaultExpectation == nil {
		mmCheckTaskStatus.defaultExpectation = &TaskServiceMockCheckTaskStatusExpectation{}
	}

	if mmCheckTaskStatus.defaultExpectation.paramPtrs != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by ExpectParams functions")
	}

	mmCheckTaskStatus.defaultExpectation.params = &TaskServiceMockCheckTaskStatusParams{taskIdentification}
	mmCheckTaskStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckTaskStatus.expectations {
		if minimock.Equal(e.params, mmCheckTaskStatus.defaultExpectation.params) {
			mmCheckTaskStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckTaskStatus.defaultExpectation.params)
		}
	}

	return mmCheckTaskStatus
}

// ExpectTaskIdentificationParam1 sets up expected param taskIdentification for TaskService.CheckTaskStatus
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) ExpectTaskIdentificationParam1(taskIdentification string) *mTaskServiceMockCheckTaskStatus {
	if mmCheckTaskStatus.mock.funcCheckTaskStatus != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by Set")
	}

	if mmCheckTaskStatus.defaultExpectation == nil {
		mmCheckTaskStatus.defaultExpectation = &TaskServiceMockCheckTaskStatusExpectation{}
	}

	if mmCheckTaskStatus.defaultExpectation.params != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by Expect")
	}

	if mmCheckTaskStatus.defaultExpectation.paramPtrs == nil {
		mmCheckTaskStatus.defaultExpectation.paramPtrs = &TaskServiceMockCheckTaskStatusParamPtrs{}
	}
	mmCheckTaskStatus.defaultExpectation.paramPtrs.taskIdentification = &taskIdentification
	mmCheckTaskStatus.defaultExpectation.expectationOrigins.originTaskIdentification = minimock.CallerInfo(1)

	return mmCheckTaskStatus
}

// Inspect accepts an inspector function that has same arguments as the TaskService.CheckTaskStatus
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Inspect(f func(taskIdentification string)) *mTaskServiceMockCheckTaskStatus {
	if mmCheckTaskStatus.mock.inspectFuncCheckTaskStatus != nil {
		mmCheckTaskStatus.mock.t.Fatalf("Inspect function is already set for TaskServiceMock.CheckTaskStatus")
	}

	mmCheckTaskStatus.mock.inspectFuncCheckTaskStatus = f

	return mmCheckTaskStatus
}

// Return sets up results that will be returned by TaskService.CheckTaskStatus
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Return(tp1 *models.Task, err error) *TaskServiceMock {
	if mmCheckTaskStatus.mock.funcCheckTaskStatus != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by Set")
	}

	if mmCheckTaskStatus.defaultExpectation == nil {
		mmCheckTaskStatus.defaultExpectation = &TaskServiceMockCheckTaskStatusExpectation{mock: mmCheckTaskStatus.mock}
	}
	mmCheckTaskStatus.defaultExpectation.results = &TaskServiceMockCheckTaskStatusResults{tp1, err}
	mmCheckTaskStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckTaskStatus.mock
}

// Set uses given function f to mock the TaskService.CheckTaskStatus method
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Set(f func(taskIdentification string) (tp1 *models.Task, err error)) *TaskServiceMock {
	if mmCheckTaskStatus.defaultExpectation != nil {
		mmCheckTaskStatus.mock.t.Fatalf("Default expectation is already set for the TaskService.CheckTaskStatus method")
	}

	if len(mmCheckTaskStatus.expectations) > 0 {
		mmCheckTaskStatus.mock.t.Fatalf("Some expectations are already set for the TaskService.CheckTaskStatus method")
	}

	mmCheckTaskStatus.mock.funcCheckTaskStatus = f
	mmCheckTaskStatus.mock.funcCheckTaskStatusOrigin = minimock.CallerInfo(1)
	return mmCheckTaskStatus.mock
}

// When sets expectation for the TaskService.CheckTaskStatus which will trigger the result defined by the following
// Then helper
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) When(taskIdentification string) *TaskServiceMockCheckTaskStatusExpectation {
	if mmCheckTaskStatus.mock.funcCheckTaskStatus != nil {
		mmCheckTaskStatus.mock.t.Fatalf("TaskServiceMock.CheckTaskStatus mock is already set by Set")
	}

	expectation := &TaskServiceMockCheckTaskStatusExpectation{
		mock:               mmCheckTaskStatus.mock,
		params:             &TaskServiceMockCheckTaskStatusParams{taskIdentification},
		expectationOrigins: TaskServiceMockCheckTaskStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckTaskStatus.expectations = append(mmCheckTaskStatus.expectations, expectation)
	return expectation
}

// Then sets up TaskService.CheckTaskStatus return parameters for the expectation previously defined by the When method
func (e *TaskServiceMockCheckTaskStatusExpectation) Then(tp1 *models.Task, err error) *TaskServiceMock {
	e.results = &TaskServiceMockCheckTaskStatusResults{tp1, err}
	return e.mock
}

// Times sets number of times TaskService.CheckTaskStatus should be invoked
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Times(n uint64) *mTaskServiceMockCheckTaskStatus {
	if n == 0 {
		mmCheckTaskStatus.mock.t.Fatalf("Times of TaskServiceMock.CheckTaskStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckTaskStatus.expectedInvocations, n)
	mmCheckTaskStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckTaskStatus
}

func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) invocationsDone() bool {
	if len(mmCheckTaskStatus.expectations) == 0 && mmCheckTaskStatus.defaultExpectation == nil && mmCheckTaskStatus.mock.funcCheckTaskStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckTaskStatus.mock.afterCheckTaskStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckTaskStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckTaskStatus implements mm_service.TaskService
func (mmCheckTaskStatus *TaskServiceMock) CheckTaskStatus(taskIdentification string) (tp1 *models.Task, err error) {
	mm_atomic.AddUint64(&mmCheckTaskStatus.beforeCheckTaskStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckTaskStatus.afterCheckTaskStatusCounter, 1)

	mmCheckTaskStatus.t.Helper()

	if mmCheckTaskStatus.inspectFuncCheckTaskStatus != nil {
		mmCheckTaskStatus.inspectFuncCheckTaskStatus(taskIdentification)
	}

	mm_params := TaskServiceMockCheckTaskStatusParams{taskIdentification}

	// Record call args
	mmCheckTaskStatus.CheckTaskStatusMock.mutex.Lock()
	mmCheckTaskStatus.CheckTaskStatusMock.callArgs = append(mmCheckTaskStatus.CheckTaskStatusMock.callArgs, &mm_params)
	mmCheckTaskStatus.CheckTaskStatusMock.mutex.Unlock()

	for _, e := range mmCheckTaskStatus.CheckTaskStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.params
		mm_want_ptrs := mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.paramPtrs

		mm_got := TaskServiceMockCheckTaskStatusParams{taskIdentification}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.taskIdentification != nil && !minimock.Equal(*mm_want_ptrs.taskIdentification, mm_got.taskIdentification) {
				mmCheckTaskStatus.t.Errorf("TaskServiceMock.CheckTaskStatus got unexpected parameter taskIdentification, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.expectationOrigins.originTaskIdentification, *mm_want_ptrs.taskIdentification, mm_got.taskIdentification, minimock.Diff(*mm_want_ptrs.taskIdentification, mm_got.taskIdentification))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckTaskStatus.t.Errorf("TaskServiceMock.CheckTaskStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckTaskStatus.CheckTaskStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckTaskStatus.t.Fatal("No results are set for the TaskServiceMock.CheckTaskStatus")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmCheckTaskStatus.funcCheckTaskStatus != nil {
		return mmCheckTaskStatus.funcCheckTaskStatus(taskIdentification)
	}
	mmCheckTaskStatus.t.Fatalf("Unexpected call to TaskServiceMock.CheckTaskStatus. %v", taskIdentification)
	return
}

// CheckTaskStatusAfterCounter returns a count of finished TaskServiceMock.CheckTaskStatus invocations
func (mmCheckTaskStatus *TaskServiceMock) CheckTaskStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckTaskStatus.afterCheckTaskStatusCounter)
}

// CheckTaskStatusBeforeCounter returns a count of TaskServiceMock.CheckTaskStatus invocations
func (mmCheckTaskStatus *TaskServiceMock) CheckTaskStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckTaskStatus.beforeCheckTaskStatusCounter)
}

// Calls returns a list of arguments used in each call to TaskServiceMock.CheckTaskStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckTaskStatus *mTaskServiceMockCheckTaskStatus) Calls() []*TaskServiceMockCheckTaskStatusParams {
	mmCheckTaskStatus.mutex.RLock()

	argCopy := make([]*TaskServiceMockCheckTaskStatusParams, len(mmCheckTaskStatus.callArgs))
	copy(argCopy, mmCheckTaskStatus.callArgs)

	mmCheckTaskStatus.mutex.RUnlock()

	return argCopy
}

// MinimockCheckTaskStatusDone returns true if the count of the CheckTaskStatus invocations corresponds
// the number of defined expectations
func (m *TaskServiceMock) MinimockCheckTaskStatusDone() bool {
	if m.CheckTaskStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckTaskStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckTaskStatusMock.invocationsDone()
}

// MinimockCheckTaskStatusInspect logs each unmet expectation
func (m *TaskServiceMock) MinimockCheckTaskStatusInspect() {
	for _, e := range m.CheckTaskStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TaskServiceMock.CheckTaskStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckTaskStatusCounter := mm_atomic.LoadUint64(&m.afterCheckTaskStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckTaskStatusMock.defaultExpectation != nil && afterCheckTaskStatusCounter < 1 {
		if m.CheckTaskStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TaskServiceMock.CheckTaskStatus at\n%s", m.CheckTaskStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TaskServiceMock.CheckTaskStatus at\n%s with params: %#v", m.CheckTaskStatusMock.defaultExpectation.expectationOrigins.origin, *m.CheckTaskStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckTaskStatus != nil && afterCheckTaskStatusCounter < 1 {
		m.t.Errorf("Expected call to TaskServiceMock.CheckTaskStatus at\n%s", m.funcCheckTaskStatusOrigin)
	}

	if !m.CheckTaskStatusMock.invocationsDone() && afterCheckTaskStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to TaskServiceMock.CheckTaskStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckTaskStatusMock.expectedInvocations), m.CheckTaskStatusMock.expectedInvocationsOrigin, afterCheckTaskStatusCounter)
	}
}

type mTaskServiceMockCreateTask struct {
	optional           bool
	mock               *TaskServiceMock
	defaultExpectation *TaskServiceMockCreateTaskExpectation
	expectations       []*TaskServiceMockCreateTaskExpectation

	callArgs []*TaskServiceMockCreateTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TaskServiceMockCreateTaskExpectation specifies expectation struct of the TaskService.CreateTask
type TaskServiceMockCreateTaskExpectation struct {
	mock               *TaskServiceMock
	params             *TaskServiceMockCreateTaskParams
	paramPtrs          *TaskServiceMockCreateTaskParamPtrs
	expectationOrigins TaskServiceMockCreateTaskExpectationOrigins
	results            *TaskServiceMockCreateTaskResults
	returnOrigin       string
	Counter            uint64
}

// TaskServiceMockCreateTaskParams contains parameters of the TaskService.CreateTask
type TaskServiceMockCreateTaskParams struct {
	task *models.Task
}

// TaskServiceMockCreateTaskParamPtrs contains pointers to parameters of the TaskService.CreateTask
type TaskServiceMockCreateTaskParamPtrs struct {
	task **models.Task
}

// TaskServiceMockCreateTaskResults contains results of the TaskService.CreateTask
type TaskServiceMockCreateTaskResults struct {
	taskId string
	err    error
}

// TaskServiceMockCreateTaskOrigins contains origins of expectations of the TaskService.CreateTask
type TaskServiceMockCreateTaskExpectationOrigins struct {
	origin     string
	originTask string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTask *mTaskServiceMockCreateTask) Optional() *mTaskServiceMockCreateTask {
	mmCreateTask.optional = true
	return mmCreateTask
}

// Expect sets up expected params for TaskService.CreateTask
func (mmCreateTask *mTaskServiceMockCreateTask) Expect(task *models.Task) *mTaskServiceMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TaskServiceMockCreateTaskExpectation{}
	}

	if mmCreateTask.defaultExpectation.paramPtrs != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by ExpectParams functions")
	}

	mmCreateTask.defaultExpectation.params = &TaskServiceMockCreateTaskParams{task}
	mmCreateTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTask.expectations {
		if minimock.Equal(e.params, mmCreateTask.defaultExpectation.params) {
			mmCreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTask.defaultExpectation.params)
		}
	}

	return mmCreateTask
}

// ExpectTaskParam1 sets up expected param task for TaskService.CreateTask
func (mmCreateTask *mTaskServiceMockCreateTask) ExpectTaskParam1(task *models.Task) *mTaskServiceMockCreateTask {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TaskServiceMockCreateTaskExpectation{}
	}

	if mmCreateTask.defaultExpectation.params != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by Expect")
	}

	if mmCreateTask.defaultExpectation.paramPtrs == nil {
		mmCreateTask.defaultExpectation.paramPtrs = &TaskServiceMockCreateTaskParamPtrs{}
	}
	mmCreateTask.defaultExpectation.paramPtrs.task = &task
	mmCreateTask.defaultExpectation.expectationOrigins.originTask = minimock.CallerInfo(1)

	return mmCreateTask
}

// Inspect accepts an inspector function that has same arguments as the TaskService.CreateTask
func (mmCreateTask *mTaskServiceMockCreateTask) Inspect(f func(task *models.Task)) *mTaskServiceMockCreateTask {
	if mmCreateTask.mock.inspectFuncCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("Inspect function is already set for TaskServiceMock.CreateTask")
	}

	mmCreateTask.mock.inspectFuncCreateTask = f

	return mmCreateTask
}

// Return sets up results that will be returned by TaskService.CreateTask
func (mmCreateTask *mTaskServiceMockCreateTask) Return(taskId string, err error) *TaskServiceMock {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by Set")
	}

	if mmCreateTask.defaultExpectation == nil {
		mmCreateTask.defaultExpectation = &TaskServiceMockCreateTaskExpectation{mock: mmCreateTask.mock}
	}
	mmCreateTask.defaultExpectation.results = &TaskServiceMockCreateTaskResults{taskId, err}
	mmCreateTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTask.mock
}

// Set uses given function f to mock the TaskService.CreateTask method
func (mmCreateTask *mTaskServiceMockCreateTask) Set(f func(task *models.Task) (taskId string, err error)) *TaskServiceMock {
	if mmCreateTask.defaultExpectation != nil {
		mmCreateTask.mock.t.Fatalf("Default expectation is already set for the TaskService.CreateTask method")
	}

	if len(mmCreateTask.expectations) > 0 {
		mmCreateTask.mock.t.Fatalf("Some expectations are already set for the TaskService.CreateTask method")
	}

	mmCreateTask.mock.funcCreateTask = f
	mmCreateTask.mock.funcCreateTaskOrigin = minimock.CallerInfo(1)
	return mmCreateTask.mock
}

// When sets expectation for the TaskService.CreateTask which will trigger the result defined by the following
// Then helper
func (mmCreateTask *mTaskServiceMockCreateTask) When(task *models.Task) *TaskServiceMockCreateTaskExpectation {
	if mmCreateTask.mock.funcCreateTask != nil {
		mmCreateTask.mock.t.Fatalf("TaskServiceMock.CreateTask mock is already set by Set")
	}

	expectation := &TaskServiceMockCreateTaskExpectation{
		mock:               mmCreateTask.mock,
		params:             &TaskServiceMockCreateTaskParams{task},
		expectationOrigins: TaskServiceMockCreateTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTask.expectations = append(mmCreateTask.expectations, expectation)
	return expectation
}

// Then sets up TaskService.CreateTask return parameters for the expectation previously defined by the When method
func (e *TaskServiceMockCreateTaskExpectation) Then(taskId string, err error) *TaskServiceMock {
	e.results = &TaskServiceMockCreateTaskResults{taskId, err}
	return e.mock
}

// Times sets number of times TaskService.CreateTask should be invoked
func (mmCreateTask *mTaskServiceMockCreateTask) Times(n uint64) *mTaskServiceMockCreateTask {
	if n == 0 {
		mmCreateTask.mock.t.Fatalf("Times of TaskServiceMock.CreateTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTask.expectedInvocations, n)
	mmCreateTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTask
}

func (mmCreateTask *mTaskServiceMockCreateTask) invocationsDone() bool {
	if len(mmCreateTask.expectations) == 0 && mmCreateTask.defaultExpectation == nil && mmCreateTask.mock.funcCreateTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTask.mock.afterCreateTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTask implements mm_service.TaskService
func (mmCreateTask *TaskServiceMock) CreateTask(task *models.Task) (taskId string, err error) {
	mm_atomic.AddUint64(&mmCreateTask.beforeCreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTask.afterCreateTaskCounter, 1)

	mmCreateTask.t.Helper()

	if mmCreateTask.inspectFuncCreateTask != nil {
		mmCreateTask.inspectFuncCreateTask(task)
	}

	mm_params := TaskServiceMockCreateTaskParams{task}

	// Record call args
	mmCreateTask.CreateTaskMock.mutex.Lock()
	mmCreateTask.CreateTaskMock.callArgs = append(mmCreateTask.CreateTaskMock.callArgs, &mm_params)
	mmCreateTask.CreateTaskMock.mutex.Unlock()

	for _, e := range mmCreateTask.CreateTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.taskId, e.results.err
		}
	}

	if mmCreateTask.CreateTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTask.CreateTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTask.CreateTaskMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTask.CreateTaskMock.defaultExpectation.paramPtrs

		mm_got := TaskServiceMockCreateTaskParams{task}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.task != nil && !minimock.Equal(*mm_want_ptrs.task, mm_got.task) {
				mmCreateTask.t.Errorf("TaskServiceMock.CreateTask got unexpected parameter task, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTask.CreateTaskMock.defaultExpectation.expectationOrigins.originTask, *mm_want_ptrs.task, mm_got.task, minimock.Diff(*mm_want_ptrs.task, mm_got.task))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTask.t.Errorf("TaskServiceMock.CreateTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTask.CreateTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTask.CreateTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTask.t.Fatal("No results are set for the TaskServiceMock.CreateTask")
		}
		return (*mm_results).taskId, (*mm_results).err
	}
	if mmCreateTask.funcCreateTask != nil {
		return mmCreateTask.funcCreateTask(task)
	}
	mmCreateTask.t.Fatalf("Unexpected call to TaskServiceMock.CreateTask. %v", task)
	return
}

// CreateTaskAfterCounter returns a count of finished TaskServiceMock.CreateTask invocations
func (mmCreateTask *TaskServiceMock) CreateTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.afterCreateTaskCounter)
}

// CreateTaskBeforeCounter returns a count of TaskServiceMock.CreateTask invocations
func (mmCreateTask *TaskServiceMock) CreateTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTask.beforeCreateTaskCounter)
}

// Calls returns a list of arguments used in each call to TaskServiceMock.CreateTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTask *mTaskServiceMockCreateTask) Calls() []*TaskServiceMockCreateTaskParams {
	mmCreateTask.mutex.RLock()

	argCopy := make([]*TaskServiceMockCreateTaskParams, len(mmCreateTask.callArgs))
	copy(argCopy, mmCreateTask.callArgs)

	mmCreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTaskDone returns true if the count of the CreateTask invocations corresponds
// the number of defined expectations
func (m *TaskServiceMock) MinimockCreateTaskDone() bool {
	if m.CreateTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTaskMock.invocationsDone()
}

// MinimockCreateTaskInspect logs each unmet expectation
func (m *TaskServiceMock) MinimockCreateTaskInspect() {
	for _, e := range m.CreateTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TaskServiceMock.CreateTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTaskCounter := mm_atomic.LoadUint64(&m.afterCreateTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTaskMock.defaultExpectation != nil && afterCreateTaskCounter < 1 {
		if m.CreateTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TaskServiceMock.CreateTask at\n%s", m.CreateTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TaskServiceMock.CreateTask at\n%s with params: %#v", m.CreateTaskMock.defaultExpectation.expectationOrigins.origin, *m.CreateTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTask != nil && afterCreateTaskCounter < 1 {
		m.t.Errorf("Expected call to TaskServiceMock.CreateTask at\n%s", m.funcCreateTaskOrigin)
	}

	if !m.CreateTaskMock.invocationsDone() && afterCreateTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to TaskServiceMock.CreateTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTaskMock.expectedInvocations), m.CreateTaskMock.expectedInvocationsOrigin, afterCreateTaskCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TaskServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelAllTasksInspect()

			m.MinimockCheckTaskStatusInspect()

			m.MinimockCreateTaskInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TaskServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TaskServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelAllTasksDone() &&
		m.MinimockCheckTaskStatusDone() &&
		m.MinimockCreateTaskDone()
}
